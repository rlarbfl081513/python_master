# ✅ 리스트 복사와 정렬 정리

## 복사의 종류

| 복사 방식 | 원본 영향 | 설명 |
|-----------|------------|------|
| 얕은 복사 (`copy`) | O (중첩 리스트 영향) | 리스트는 새로 만들지만 내부 객체는 공유 |
| 깊은 복사 (`deepcopy`) | X | 완전히 새로운 리스트 및 내부 객체 생성 |
| 슬라이싱 (`[:]`) | X (단일 리스트만) | 얕은 복사와 같음 |
| 단순 할당 (`b = a`) | O | 같은 리스트 참조 (원본도 바뀜) |

### 예시
```python
a = [1, 2, [3, 4]]
b = a.copy()        # 얕은 복사
b[2][0] = 100
print(a)  # [1, 2, [100, 4]]

import copy
c = copy.deepcopy(a)  # 깊은 복사
c[2][0] = 999
print(a)  # [1, 2, [100, 4]]
```

## 리스트 정렬 및 반전

| 함수 | 원본 변경 | 반환값 | 설명 |
|------|-----------|--------|------|
| `list.sort()` | O | `None` | 제자리 정렬 |
| `sorted(list)` | X | 정렬된 리스트 | 원본 유지 |
| `list.reverse()` | O | `None` | 리스트 뒤집기 (역순) |
| `reversed(list)` | X | 반복자 | 역순 반복자 반환 (list로 감싸야 사용 가능) |

### 예시
```python
arr = [3, 1, 2]
arr.sort()
print(arr)  # [1, 2, 3]

arr2 = [3, 1, 2]
new_arr = sorted(arr2)
print(arr2)     # [3, 1, 2]
print(new_arr)  # [1, 2, 3]

r = list(reversed(arr2))
print(r)  # [2, 1, 3]
```

> `reversed()`는 반복자(iterator)를 반환하므로 리스트처럼 `pop()` 등의 메서드를 사용할 수 없다. 
> 반복자로 사용하려면 `next()` 또는 `for` 루프를 사용하거나 `list()`로 감싸서 리스트로 변환해야 한다.

```python
r = reversed([1, 2, 3])
print(next(r))  # 3

for item in r:
    print(item)  # 반복자 순회

r_list = list(reversed([1, 2, 3]))
r_list.pop()  # 가능
```
## reversed()와 슬라이싱 복사 정리
### reversed() 함수

### 특징
- `reversed(리스트)`는 **역순 반복자(iterator)** 를 반환한다
- **리스트 메서드 사용 불가** (`pop`, `append`, 인덱싱 등)
- 주로 **for문에서 역순 순회**에 사용됨
- 메모리 효율이 좋고, 슬라이싱보다 의도가 명확함

### 사용 예시
```python
arr = [1, 2, 3, 4]

# 역순으로 순회 (list로 변환할 필요 없음)
for x in reversed(arr):
    print(x)  # 4, 3, 2, 1

# 리스트로 변환해야 pop 등의 메서드 사용 가능
r_list = list(reversed(arr))
print(r_list.pop())  # 1 (뒤에서 pop)
```

### 주의사항
- `reversed()` 자체는 반복자이므로 `list()`로 감싸야 인덱싱이나 `pop()` 가능
- 순회 목적이 아니면 `[::-1]` 슬라이싱이 더 편할 수도 있음

---

### 슬라이싱 복사 (`[:]`, `[::-1]`)

### `[:]` — 전체 복사
- 리스트 전체를 얕은 복사(shallow copy)
- 원본은 유지되며 새 리스트를 반환

```python
a = [1, 2, 3]
b = a[:]
b[0] = 100
print(a)  # [1, 2, 3] (원본 유지)
```

### `[::-1]` — 역순 복사
- 리스트를 **뒤집어서 복사**
- 원본을 유지하며 역순 리스트 생성

```python
a = [1, 2, 3]
b = a[::-1]
print(b)  # [3, 2, 1]
```

### 차이점 정리
| 방식 | 반환값 | 목적 | 메모리 복사 | 메서드 사용 가능 |
|-------|--------|------|----------------|------------------|
| `reversed()` | 반복자 | 순회 | ❌ (복사 안 함) | ❌ |
| `list(reversed())` | 리스트 | 역순 리스트 | ✅ | ✅ |
| `a[::-1]` | 리스트 | 역순 복사 | ✅ | ✅ |
| `a[:]` | 리스트 | 얕은 복사 | ✅ | ✅ |

---

## 정리
- 반복자만 필요하면 `reversed()`가 효율적이고 깔끔함
- 리스트로 조작하려면 `list(reversed(...))` 또는 `[::-1]` 사용
- `[:]`, `[::-1]`은 둘 다 복사이며 리스트로서 바로 사용 가능



## next() 함수란?
- 반복자(iterator)에서 다음 값을 하나 꺼내오는 함수
- 내부적으로 `__next__()`를 호출함
- 더 이상 꺼낼 값이 없으면 `StopIteration` 예외 발생

```python
it = iter([10, 20, 30])
print(next(it))  # 10
print(next(it))  # 20
```

## 변수 할당과 리스트 값 변경

```python
x = [10, 20, 30]
i = x[1]    # 값 복사 (i는 20이라는 숫자)
i = 50      # x에는 영향 없음
print(x)    # [10, 20, 30]

x[1] = 50   # 직접 리스트 인덱스를 수정해야 변경됨
print(x)    # [10, 50, 30]
```

> 리스트 내부 값을 바꾸고 싶다면 반드시 `x[index] = 값` 형태로 직접 수정해야 한다.

---
# 🧮 Python 정렬: sort() vs sorted()

파이썬에서 리스트를 정렬할 때 자주 사용하는 두 가지 방법인 `sort()`와 `sorted()`의 차이를 명확하게 정리합니다.

---

## ✅ sort()

- **리스트 객체 자체를 정렬**합니다 (in-place 정렬)
- **반환값이 없음** (`None`을 반환)
- 원본 리스트를 직접 바꿉니다

### 📌 사용법
```python
nums = [3, 1, 2]
nums.sort()
print(nums)  # [1, 2, 3]
```

### ⚠️ 주의점
- 원본 데이터가 훼손될 수 있으므로 **복사본을 만든 후 사용하는 것이 안전**합니다.

---

## ✅ sorted()

- **원본 리스트는 그대로 유지**하고, 정렬된 새로운 리스트를 반환합니다
- **모든 iterable 객체**에 사용 가능 (예: 리스트, 튜플, 문자열 등)

### 📌 사용법
```python
nums = [3, 1, 2]
new_nums = sorted(nums)
print(new_nums)  # [1, 2, 3]
print(nums)      # [3, 1, 2] (원본 유지)
```

---

## 🔍 비교 요약

| 항목 | `sort()` | `sorted()` |
|------|----------|------------|
| 반환값 | `None` | 정렬된 새 리스트 |
| 원본 변경 | ✅ 변경됨 | ❌ 유지됨 |
| 사용 가능 대상 | 리스트 객체 | 모든 iterable 객체 |
| 사용 예 | `a.sort()` | `sorted(a)` |

---

## ✅ 언제 무엇을 써야 할까?

| 상황 | 추천 함수 | 이유 |
|------|------------|------|
| 리스트 자체를 바꿔도 상관없을 때 | `sort()` | 메모리 효율 좋음 |
| 원본을 유지하고 정렬 결과만 필요할 때 | `sorted()` | 데이터 보호, 직관적 |
| zip, set, dict 등 리스트가 아닌 iterable을 정렬할 때 | `sorted()` | `sort()`는 리스트에만 적용 가능 |

---

> ⚠️ `sort()`는 리스트 자체를 변경하므로, **세로 탐색(zip), 원본 보존이 필요한 경우에는 절대 사용하면 안 됨.** 이런 경우에는 반드시 `sorted()`를 사용하세요.

---

# 🐍 Python zip() 함수 정리

## ✅ zip() 기본 개념

- `zip()`은 여러 개의 iterable(리스트, 튜플 등)을 병렬로 묶어주는 함수입니다.
- 각 iterable의 같은 인덱스에 있는 요소들을 튜플로 묶어서 반환합니다.
- 반환값은 zip 객체이므로 list로 변환하여 확인합니다.

### 📌 기본 예제

```python
a = [1, 2, 3]
b = ['a', 'b', 'c']

zipped = zip(a, b)
print(list(zipped))
# 출력: [(1, 'a'), (2, 'b'), (3, 'c')]
```

---

## ✅ zip(*iterables) 활용: 2차원 리스트 전치 (Transpose)

- `zip(*matrix)`를 사용하면 2차원 리스트의 행과 열을 뒤바꾸는 전치(Transpose) 효과를 얻을 수 있습니다.
- 행렬의 전치: `matrix[i][j]` → `matrix[j][i]`
- zip()은 **여러 iterable(반복 가능한 객체)**을 인자로 받아. 인자 개수는 자유로워! (2개든, 5개든, 100개든) 단, 결과는 가장 짧은 길이에 맞춰서 짝지어져.
  ```python
    a = [1, 2]
    b = ['a', 'b', 'c']
    c = ['x', 'y', 'z']
    
    print(list(zip(a, b, c)))
    # → [(1, 'a', 'x'), (2, 'b', 'y')]  ← 제일 짧은 길이 2개만 묶임

   ```
### 📌 예제

```python
matrix = [
    [1, 0, 1],
    [1, 1, 1],
    [0, 1, 0]
]

for col in zip(*matrix):
    print(col)
```

### 📌 출력 결과

```
(1, 1, 0)
(0, 1, 1)
(1, 1, 0)
```

> 💡 2차원 리스트에서 열을 가로 방향처럼 처리할 때 자주 사용됩니다.

---

## ✅ 정리 요약

| 기능 | 설명 |
|------|------|
| `zip(a, b)` | 리스트 a와 b를 인덱스 기준으로 묶어서 튜플 생성 |
| `zip(*matrix)` | 2차원 리스트의 전치(transpose) 수행 

-- |

---
다음은 위에서 다룬 **리스트 vs 집합의 탐색 성능** 차이와, 이를 활용한 시간 최적화 팁을 정리한 마크다운입니다:

---
---