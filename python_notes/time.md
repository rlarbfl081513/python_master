# 🔍 슬라이싱과 max 연산의 시간복잡도 비교
[예제 코드 보기](../algorithm/List_&_String/List/1206_view.py/)

## ✅ 문제 상황
```python
max(arr[i-2:i] + arr[i+1:i+3])
```
- 이 표현식은 슬라이싱과 리스트 덧셈 연산을 포함함
- 다음과 같은 파이썬 코드로 동작함

## ✅ 이 코드의 단계별 분석

### 1. 슬라이싱(arr[i-2:i])으로 리스트 복사
```python
arr[i-2:i]  # 왼쪽 2개
arr[i+1:i+3]  # 오른쪽 2개
```
- 각각 **2개의 값을 복사한 새 리스트 생성**
- 값을 복사하면서 리스트를 생성 → O(2) + O(2) = O(4)

### 2. 리스트 덧셈 (`+`)
```python
arr[i-2:i] + arr[i+1:i+3]
```
- 두 리스트를 하나로 합치기 위해 새 리스트 생성
- 총 4개의 값 복사 → O(4)

### 3. max 연산
```python
max([a, b, c, d])
```
- 4개의 값을 비교 → O(4)

---

## ✅ 총 시간 계산
| 작업 | 시간 |
|--------|--------|
| 슬라이싱 2번 | O(2+2) = O(4) |
| 리스트 덧셈 | O(4) |
| max 연산 | O(4) |
| → 총합 | 약 O(12) |

> 시간복잡도에서 리스트 복사와 생성이 추가되며, max 수행까지 포함되어 성능에 부담을 줌

---

## ✅ 더 효율적인 방식
```python
max(arr[i-2], arr[i-1], arr[i+1], arr[i+2])
```
- 새 리스트를 만들지 않고 각 값에 직접 접근
- 리스트 복사 없이 비교만 수행하므로 → O(4)

---

## ✅ 결론
| 방식 | 발생하는 작업 | 시간 |
|--------|---------------|------|
| 슬라이싱+리스트+최댓값 | 리스트 3개 생성 | O(12) 정도 |
| 직접 인덱스 접근 | 생성 작업 없음 | O(4) |

> 상수 시간복잡도는 같지만, 불필요한 리스트 생성과 복사를 줄이는 것이 효율적

