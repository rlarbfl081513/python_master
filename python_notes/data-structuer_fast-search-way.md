
# 🔍 리스트 탐색 vs 집합 탐색 성능 비교

## ✅ 문제 상황
- 2차원 배열(아파트 주민)을 순회하며, 특정 값(블랙리스트)이 포함되어 있는지 확인해야 하는 경우
- 다음과 같이 `if val in 리스트:`를 반복 수행하면 **시간 초과** 가능성이 높음

## 🐢 리스트(List) 탐색
```python
if val in some_list:
    ...
```

- **시간복잡도**: O(N)
- 리스트는 처음부터 끝까지 순차적으로 비교함
- 데이터 수가 많아질수록 선형 시간 증가

## ⚡ 집합(Set) 탐색
```python
some_set = set(some_list)
if val in some_set:
    ...
```

- **시간복잡도**: 평균 O(1)
- `HashTable` 기반으로 구현되어 있어 탐색이 빠름
- **조건 판단이 많은 경우 필수적으로 사용해야 시간초과 방지 가능**

---

## 🔧 적용 예시

### 문제 코드 (시간 초과 발생 가능)
```python
for row in a_arr:
    for val in row:
        if val in blacklist_list:  # O(N) 연산 반복
            cnt += 1
```

### 개선 코드 (set으로 변경)
```python
blacklist_set = set(sum(b_arr, []))  # 2차원 리스트를 1차원으로 평탄화 후 집합 변환

for row in a_arr:
    for val in row:
        if val in blacklist_set:  # O(1) 연산으로 개선
            cnt += 1
```

---

## ⛳ 실전 팁

| 상황 | 리스트(List) | 집합(Set) |
|------|------------------|--------------------|
| 순서를 유지해야 함 | ✅ 사용 가능 | ❌ 순서 없음 |
| 중복 제거가 필요함 | ❌ 불리함 | ✅ 자동 제거 |
| 탐색 성능이 중요함 | ❌ 느림 (O(N)) | ✅ 빠름 (O(1)) |
| 데이터 크기가 크고 `in` 연산이 많음 | ❌ 시간초과 위험 | ✅ 최적 |

---

## 📌 결론
> `if val in 리스트:`를 반복적으로 사용할 경우, 리스트 대신 **집합(set)** 으로 변환해서 사용하면 시간 복잡도를 **O(N) → O(1)** 로 줄일 수 있다.

---

# 🔢 dat 리스트란 무엇인가?

## ✅ 정의
`dat`는 일반적으로 알고리즘 문제나 대회 코드에서 자주 사용되는 **"데이터 체크 배열"**을 의미하는 변수명으로, **특정 정수 값의 존재 여부나 상태를 빠르게 확인하기 위해 사용하는 리스트**입니다.


## ✅ 왜 `dat`라는 이름을 사용할까?

| 관습적 약어 | 의미 |
|-------------|------|
| `dat`       | `data` 또는 `data table`의 축약형으로, 데이터의 상태를 저장하는 공간이라는 의미로 자주 사용됨 |

- 프로그래밍 대회나 알고리즘 문제에서는 **간결한 변수명을 선호**하기 때문에 `check_list`, `exist_table`보다 `dat`가 짧고 빠르게 쓸 수 있음
- C언어나 Python에서 빠른 인덱스 접근이 가능한 구조로, **`dat[num]`이라는 형태로 빠른 조회**가 가능하게 하려는 목적

---

## ✅ 사용하는 이유: 고속 탐색

- 일반적으로 어떤 값이 **존재하는지 확인**할 때 `list`의 `in` 연산자나 `set`, `dict`를 사용하는데,
  ```python
  if num in my_set:  # O(1) 평균 시간
  ```
- 하지만 **숫자의 범위가 고정되어 있고 작을 경우**, 리스트의 인덱스를 직접 활용하면 더 빠르게 확인할 수 있음
  ```python
  dat = [0] * 100001
  dat[37] = 1  # 존재 표시
  if dat[37]:  # 빠른 확인
      print("존재함")
  ```

---

## ✅ 예시 코드: 블랙리스트 확인
```python
T = int(input())

for tc in range(1, T + 1):
    h, w = map(int, input().split())
    apartments = [list(map(int, input().split())) for _ in range(h)]

    bh, bw = map(int, input().split())
    black_list = [list(map(int, input().split())) for _ in range(bh)]

    dat = [0] * 100001  # 최대 값이 100000이라고 가정

    # 블랙리스트 체크
    for i in range(bh):
        for j in range(bw):
            dat[black_list[i][j]] = 1

    black_cnt = 0
    for i in range(h):
        for j in range(w):
            if dat[apartments[i][j]]:
                black_cnt += 1

    print(f'#{tc} {black_cnt} {(h*w) - black_cnt}')
```

---
## ✅ 예시 코드: 성실한 사원
- dat의 런타임에러시, 범위를 너무 크게 잡은거니까 
- 인풋에 따라 dat 리스트의 길이를 조정할 수 있도록 한다.
- [swea : 성실한 사원](../algorithm/List_&_String/List/21463_DAT-good-staft.py)
---

## ✅ 정리
| 항목 | 설명 |
|------|------|
| 목적 | 정수형 데이터의 존재 여부를 빠르게 확인하기 위함 |
| 이름 | `dat`는 관습적으로 쓰이는 약어 (`data table` 느낌) |
| 특징 | 고정된 정수 범위에서 매우 빠른 탐색 (O(1)) |
| 주의 | 정수 값의 범위가 크면 메모리 낭비 가능 |

---

좋아, 아주 중요한 개념이야. 네가 지금 헷갈린 **해시 기반 vs 배열 기반** 차이를 쉽게 설명해볼게.

---

# 해시 기반과 배열기반의 차이 
🔍 핵심 차이: **인덱스를 직접 쓰는가, 해시 함수를 쓰는가**

| 비교 항목      | 배열 기반 (DAT 방식)                        | 해시 기반 (dict / set 등)                                    |
| ---------- | ------------------------------------- | ------------------------------------------------------- |
| **인덱스**    | **숫자 그대로 사용**                         | **해시 함수로 계산된 위치 사용**                                    |
| **속도**     | 매우 빠름 (O(1))                          | 보통 빠름 (O(1) 평균, 최악 O(n))                                |
| **메모리 효율** | 정해진 범위가 작을 때 효율적                      | 범위가 크거나 희소할 때 효율적                                       |
| **사용 예**   | `dat = [0] * 10001`<br>`dat[번호] += 1` | `from collections import defaultdict`<br>`dat[번호] += 1` |

---

## 🧠 예시로 비교해볼게

### ✅ 배열 기반 (DAT 방식)

```python
dat = [0] * 10001  # 인덱스 0~10000까지 미리 확보
dat[5000] += 1     # 정류장 번호 5000번 => 인덱스 5000에 직접 접근
```

* **번호 그 자체가 인덱스**로 쓰임
* 빠르고 단순
* 정류장 번호가 1\~5000이면 딱 맞아!

### ✅ 해시 기반 (dict)

```python
from collections import defaultdict
dat = defaultdict(int)
dat[5000] += 1
```

* `5000`이라는 숫자가 해시 함수에 의해 내부적으로 변환되어 위치를 찾아감
* 정류장 번호가 `50000000` 이런 식으로 커져도 문제 없음
* 정해진 범위가 없거나 희소한 경우 유리함

---

## 📦 언제 배열 기반(DAT), 언제 해시 기반(dict)?

* **정해진 범위 안에서 정수 인덱스**를 쓸 수 있을 때 → 배열 기반 (예: 정류장 번호가 1\~5000)
* **범위가 크거나 복잡한 키 (문자열, 튜플 등)** → 해시 기반

---

## ✅ 결론

> 너처럼 `dat = [0]*5001` 하고, 정류장 번호를 그대로 인덱스로 쓰는 방식은 **배열 기반 (DAT 방식)**
> `dict[정류장번호] += 1` 식으로 쓰면 **해시 기반**.
- 배열 : 인덱스로 접근해서 그냥 리스트를 도는거고
- 해시 (딕셔너리, set) : 값을 키로 해시 계산해서 위치 찾음, 바로 찾을 수 있다는거
