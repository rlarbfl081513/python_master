# 그래프
1. 문제를 풀때
   2. 자료구조를 보고
   3. 알고리즘을 고민
## 정의
   1. 친구관계 : 친구가 가장 많은 친구는 누구인가?
   3. 아이템들과 이들 사이의 연결관계를 표현
   4. 정점과 간선
      5. 정점(vertax)들의 집합과 이들을 연결하는 간선(edge)들의 집합으로 구성된 자료구조
      6. v는 정점의 개수, e는 그래프에 포함된 간선의 개수
      7. v개의 정점을 가지는 그래프는 최대 v(v-1)/2 간선이 가능
         8. 예) 5개의 정점이 있는 그래프의 최대 간선 후는 5*4/2, 양방향을 없애기 위햇 2로 나누는 거임
      9. 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N관계를 가지는 원소들을 표현하기 용이하다.
## 그래프 유형
   1. 무향그래프 (undirected graph)
   5. 유향그래프 (directes graph)
   6. 가중치 그래프 (weighted graph) : 약간 하이패스 돈내는 느낌
   7. 사이클이 없는 방향 그래프 (DAG, directed acyclic graph)
   8. 완전 그래프 : 정점들에 대해 가능한 모든 간선들을 가진 그래프
   9. 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
## 인접 (Adjacency)
   1. 두개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 함
   6. 완전그래프에 속한 임의의 두 정점들은 모두 인접해있다.
## 그래프 경로
   1. 경로 : 간선들을 순서대로 나열한것
   7. 단순경로 : 경로 중 한 정점을 최대한 한전만 지나는 경로
   8. 사이클 : 시작한 정점에서 끝나는 경로 (뱅글뱅글 도는 그림)
   9. 추가) 정점이 두개뿐이라 서로만 왔다갔다가 해도 사이클이 존재한다고 할 수 있음
---
## 그래프 표현
1. 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
2. 인접행렬 Adiacent matrix
   3. v*v 크기의 2차원 배열을 이용해서 간선 정보를 저장
   4. 배열의 배열 (포인터 배열)
3. 인접 리스트 Adjacent List
   4. 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
5. 간선의 배열
   6. 간선(시작 정점, 끝정점)을 배열에 연속적으로 저장
### 인접 행렬
   1. 형태
       ```python
       graph = [
         [0, 1, 1],
         [1, 0, 0],
         [1, 0, 0],
       ]
1. 정의
   2. 간선의 유무를 다 표현
   3. 행렬위에 대각선으로 그어서 서로 댜칭이되면 양방향그래프(무향)
4. 단점
   5. 메모리 낭비 -> 못가는 경로도 저장하니까 -> 그래서 이를 이해 인접 리스트를 활용한다
### 인접 리스트
   1. 형태
      ```python
       graph = {
         0: [1, 2],
         1: [0],
         2: [0],
       }
1. 정의
   2. 각 정점에 대한 인접 정점들을 순차적으로 표현
   2. 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장 
   3. 단점
      4. 예) 5와3이 인접했니?? 인접행렬은 gragp[5][3]만 보면됨, 근데 인접리스트는 검색하는 시간이 더 든다. 왜냐면 5로 출발해서 다가보면서 3을 방문하는지 봐야하니까.
      5. 정점 추가 삭제 시 시간이 불리함
    <details>
    <summary>왜 시간이 더 걸리지??</summary>
    ## 정점 추가/삭제 시 비교
    
    | 작업 | 인접 리스트 | 인접 행렬 |
    |------|--------------|--------------|
    | 정점 추가 | 새 key 만들고, 연결된 간선마다 리스트 수정 → 느림 | 행과 열 하나씩 추가 → 리스트 하나 돌며 insert |
    | 정점 삭제 | 해당 key 삭제 + 다른 모든 리스트에서 그 정점 찾아 제거 | 행과 열 삭제 → 리스트 한 번만 돌면 됨 |
    | 간선 추가/삭제 | `append()`/`remove()` 정도만 해주면 됨 | `graph[i][j] = 1 or 0`으로 O(1) |
    
    ## 시간 복잡도 측면에서 보면
    
    - **인접 리스트**: 정점 삭제 시,  
    모든 정점의 인접 리스트를 **순회하면서 지워줘야** 해 → O(V)
   - **인접 행렬**: 그냥 행/열 한 줄 지우면 끝 → O(V) (비슷하지만 더 직관적이고 일관됨)
        
   ## 예시
        
     ### 인접 리스트 정점 삭제 (복잡)
     ```python
     def delete_vertex(graph, v):
         # 정점 v 제거
         graph.pop(v, None)
         # 다른 모든 인접 리스트에서 v 제거
         for key in graph:
             if v in graph[key]:
                 graph[key].remove(v)
    
        
     ### 인접 행렬 정점 삭제 (간단)
     def delete_vertex(graph, v):
         graph.pop(v)
         for row in graph:
             row.pop(v)
     ```

     ## 결론 요약
        >    인접 리스트는 정점 자체를 삭제하거나 추가할 때,  
        >    **다른 정점들과의 연결 정보도 일일이 수정해야 하기 때문에**  
        >    시간과 코드 복잡도가 더 커질 수 있다는 뜻이야.  
        >    (단순 `append` 속도 말고 전체 구조적 문제!)

6. 가중치 표현 : 튜플을 통해 가능함
   7. 예) [(3,4), (5,4)] -> 0에 연결된 3으로의 가중치는 4이다.
