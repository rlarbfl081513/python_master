## 내가한 방식은 안되고 gpt방식은 맞은 이유

지금 네가 헷갈리는 건 **"왜 16 × 16 배열에서 x * 16 + y 를 쓰는지"** 그 이유지?

---

## 왜 `x * 16 + y` 인가?

### 전제
- 우리는 2차원 미로 (`arr[x][y]`)를 보고 있어
- 근데 유니온 파인드는 **1차원 배열**로 구성돼야 해 (`parents = [0, 1, 2, ..., 255]`)
- 그래서 2차원 좌표 `(x, y)`를 **1차원 인덱스로 바꿔줘야 해**

---

### 예시로 보기

미로가 이렇게 생겼다고 해 (16x16 중 일부):

```
[ (0,0) (0,1) (0,2) (0,3) ... ]
[ (1,0) (1,1) (1,2) (1,3) ... ]
[ (2,0) (2,1) (2,2) (2,3) ... ]
...
```

여기서 `(1, 2)`라는 위치는 2차원 좌표야.  
이걸 **1차원 번호로 바꾸면 몇 번째일까?**

> → `(1, 2)` = `1 * 16 + 2` = `18`

즉, 1행에 있는 건 이미 16칸이니까 → 16개는 건너뛰고  
→ 2칸 더 간 위치 = `18번째`

---

## 더 쉬운 예시 (3x3로 단순화해서)

| 2D 좌표 | 1D 인덱스 (x * 3 + y) |
|--------|----------------------|
| (0,0)  | 0                    |
| (0,1)  | 1                    |
| (0,2)  | 2                    |
| (1,0)  | 3                    |
| (1,1)  | 4                    |
| (1,2)  | 5                    |
| (2,0)  | 6                    |
| (2,1)  | 7                    |
| (2,2)  | 8                    |

이걸 보면 아하!  
→ `x * 너비 + y` 를 하면 정확히 칸 번호가 나오네!

---

## 그래서 왜 쓰는가?

✅ 유니온 파인드는 `parents[숫자]` 이렇게 1차원 배열이어야 해서  
✅ 우리가 쓰는 좌표 `(x, y)`를 `x * 16 + y`로 바꿔줘야 함  
→ 그래야 `union()`, `find_set()` 함수에 넘길 수 있음

---

### 한 줄 요약:
> **"2차원 좌표를 1차원 배열 인덱스로 바꾸려면 `x * 열의 길이 + y` 를 쓴다!"**

---

더 궁금한 거 있으면 예시 더 들어줄게!  
"그럼 반대로 1차원에서 2차원은 어떻게 바꿔?" 같은 것도 알려줄 수 있어 😊

# 유니온파인드
